package def

import "math/big"

type NodeRole string

const (
	CollectorRole NodeRole = "collector"
	ConsensusRole NodeRole = "consensus"
	ExecutorRole  NodeRole = "executor"
	VerifierRole  NodeRole = "verifier"
	ObserverRole  NodeRole = "observer"
)

// NodeIdentity contains the properties of one node. Often, a node is part of a group.
// We assume that there exists a canonical ordering of nodes. Hence, for any fixed group
// of nodes, each is assigned a (zero-based) Index within this specific group.
// In other words, a node's index is with respect to a specific `identity.Table`.
type NodeIdentity interface {
	PubKey() []byte
	Address() string
	Role() NodeRole
	Stake() *big.Int
	Index() uint32
}

// Table holds a group of nodes. There are Count nodes in the table. Each node has a
// unique index in the range [0,1, ..., Count-1]. A new Table with a sub-set of nodes
// can be generated by filtering according to various node properties. When generating
// a new table, the nodes' indices in this new table are generated from scratch.
type Table interface {
	Count() uint32
	Nodes() []NodeIdentity
	GetSelfID() []byte
	SetSelfID([]byte)
	GetSelfIdx() uint32

	GetByIndex(uint32) (NodeIdentity, error)
	GetByID([]byte) (NodeIdentity, error)
	GetByAddress(string) (NodeIdentity, error)

	TotalStake() *big.Int

	FilterByID([][]byte) (Table, error)
	FilterByAddress([]string) (Table, error)
	FilterByRole(NodeRole) (Table, error)
	FilterByIndex([]uint32) (Table, error)

	GetPubKeysFromSignersSlice([]bool) [][]byte
	GetAddressesFromTable() []string
}
