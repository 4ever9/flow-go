package corruptible

import (
	"context"
	"fmt"
	"sync"

	"github.com/rs/zerolog"

	"github.com/onflow/flow-go/crypto/hash"
	"github.com/onflow/flow-go/engine/execution/utils"
	verutils "github.com/onflow/flow-go/engine/verification/utils"
	"github.com/onflow/flow-go/insecure"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/module"
	"github.com/onflow/flow-go/module/component"
	"github.com/onflow/flow-go/module/irrecoverable"
	"github.com/onflow/flow-go/network"
)

const networkingProtocolTCP = "tcp"

// ConduitFactory implements a corruptible conduit factory, that creates corruptible conduits and acts as their master.
// A remote attacker can register itself to this conduit factory.
// Whenever any corruptible conduit generated by this factory receives an event from its engine, it relays the event to this
// factory, which in turn is relayed to the register attacker.
// The attacker can asynchronously dictate the conduit factory to send messages on behalf of the node this factory resides on.
type ConduitFactory struct {
	component.Component
	mu             sync.Mutex
	cm             *component.ComponentManager
	logger         zerolog.Logger
	me             module.Local
	adapter        network.Adapter
	ctx            context.Context
	receiptHasher  hash.Hasher
	spockHasher    hash.Hasher
	approvalHasher hash.Hasher

	incomingMessageChan chan *insecure.Message
	egressController    insecure.EgressController
}

func NewCorruptibleConduitFactory(
	logger zerolog.Logger,
	chainId flow.ChainID,
	me module.Local,
	address string) *ConduitFactory {

	if chainId != flow.BftTestnet {
		panic("illegal chain id for using corruptible conduit factory")
	}

	factory := &ConduitFactory{
		me:                  me,
		logger:              logger.With().Str("module", "corruptible-conduit-factory").Logger(),
		receiptHasher:       utils.NewExecutionReceiptHasher(),
		spockHasher:         utils.NewSPOCKHasher(),
		approvalHasher:      verutils.NewResultApprovalHasher(),
		incomingMessageChan: make(chan *insecure.Message),
	}

	cm := component.NewComponentManagerBuilder().
		AddWorker(func(ctx irrecoverable.SignalerContext, ready component.ReadyFunc) {
			factory.start(ctx, address)
			factory.ctx = ctx

			ready()

			<-ctx.Done()

			factory.stop()
		}).Build()

	factory.Component = cm
	factory.cm = cm

	return factory
}

// ServerAddress returns address of the gRPC server that is running by this corrupted conduit factory.
func (c *ConduitFactory) ServerAddress() string {
	return c.address.String()
}

// stop conducts the termination logic of the sub-modules of attack network.
func (c *ConduitFactory) stop() {
	c.server.Stop()
}

// RegisterAdapter sets the Adapter component of the factory.
// The Adapter is a wrapper around the Network layer that only exposes the set of methods
// that are needed by a conduit.
func (c *ConduitFactory) RegisterAdapter(adapter network.Adapter) error {
	if c.adapter != nil {
		return fmt.Errorf("could not register a new network adapter, one already exists")
	}

	c.adapter = adapter

	return nil
}

// NewConduit creates a conduit on the specified channel.
// Prior to creating any conduit, the factory requires an Adapter to be registered with it.
func (c *ConduitFactory) NewConduit(ctx context.Context, channel network.Channel) (network.Conduit, error) {
	if c.adapter == nil {
		return nil, fmt.Errorf("could not create a new conduit, missing a registered network adapter")
	}

	child, cancel := context.WithCancel(ctx)

	con := &Conduit{
		ctx:              child,
		cancel:           cancel,
		channel:          channel,
		egressController: c.egressController,
	}

	return con, nil
}

// unregisterChannel is called by the slave conduits of this factory to let it know that the corresponding engine of the
// conduit is not going to use it anymore, so the channel can be closed safely.
func (c *ConduitFactory) unregisterChannel(channel network.Channel) error {
	return c.adapter.UnRegisterChannel(channel)
}

// sendOnNetwork dispatches the given event to the networking layer of the node in order to be delivered
// through the specified protocol to the target identifiers.
func (c *ConduitFactory) sendOnNetwork(event interface{},
	channel network.Channel,
	protocol insecure.Protocol,
	num uint, targetIds ...flow.Identifier) error {
	switch protocol {
	case insecure.Protocol_UNICAST:
		if len(targetIds) > 1 {
			return fmt.Errorf("more than one target ids for unicast: %v", targetIds)
		}
		return c.adapter.UnicastOnChannel(channel, event, targetIds[0])

	case insecure.Protocol_PUBLISH:
		return c.adapter.PublishOnChannel(channel, event, targetIds...)

	case insecure.Protocol_MULTICAST:
		return c.adapter.MulticastOnChannel(channel, event, num, targetIds...)
	default:
		return fmt.Errorf("unknown protocol for sending on network: %d", protocol)
	}
}
