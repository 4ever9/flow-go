package flow

import (
	"bytes"
	"fmt"

	"github.com/dapperlabs/flow-go/crypto"
	"github.com/dapperlabs/flow-go/model"
	"github.com/dapperlabs/flow-go/model/encoding"
	"github.com/dapperlabs/flow-go/model/hash"
)

// ChunkBody - body section of a chunk
type ChunkBody struct {

	// transactions info
	FirstTxIndex      uint64      // Transaction index inside the block
	TxCounts          uint32      // number of transactions in this chunk
	ChunkTxCollection crypto.Hash // Hash of collection of txs in this chunk

	// execution info
	StartState      StateCommitment // start state when starting executing this chunk
	EventCollection model.Commit    // Events generated by executing results

	// Computation consumption info
	TotalComputationUsed            uint64 // total amount of computation used by running all txs in this chunk
	FirstTransactionComputationUsed uint64 // first tx in this chunk computation usage
}

// Chunk is an aggregate execution info about a sequence of transactions
type Chunk struct {
	ChunkBody

	Index uint64 // chunk index inside the ER (starts from zero)
	// EndState inferred from next chunk or from the ER
	EndState StateCommitment
}

// Commit provides a cryptographic commitment for a chunk content
func (ch *Chunk) Commit() model.Commit {
	return model.Commit(hash.DefaultHasher.ComputeHash(encoding.DefaultEncoder.MustEncode(ch)))
}

// ID returns a unique id for this entity
func (ch *Chunk) ID() model.Identifier {
	var id model.Identifier
	copy(id[:], ch.Commit())
	return id
}

func (ch *Chunk) String() string {
	switch ch.TxCounts {
	case 0:
		return "An empty chunk"
	case 1:
		return fmt.Sprintf("chunk %v includes a single transaction (TotalGasSpent: %v)",
			ch.ID(), ch.TotalComputationUsed)
	default:
		return fmt.Sprintf(
			"Chunk %v includes %v transactions (TotalGasSpent: %v)",
			ch.ID(),
			ch.TxCounts,
			ch.TotalComputationUsed,
		)
	}
}

// Note that this is the basic version of the List, we need to substitute it with something like Merkel tree at some point
type ChunkList struct {
	chunks []Chunk
}

func (cl *ChunkList) Commit() model.Commit {
	hasher, _ := crypto.NewHasher(crypto.SHA3_256)
	for _, item := range cl.chunks {
		hasher.Add(item.Commit())
	}
	return model.Commit(hasher.SumHash())
}

func (cl *ChunkList) AppendItem(ch Chunk) {
	cl.chunks = append(cl.chunks, ch)
}

func (cl *ChunkList) Items() []Chunk {
	return cl.chunks
}

// ByCommit returns an entity from the list by entity commit
func (cl *ChunkList) ByCommit(c model.Commit) Chunk {
	for _, item := range cl.chunks {
		if bytes.Equal(item.Commit(), c) {
			return item
		}
	}
	return Chunk{}
}

// ByIndex returns an entity from the list by index
func (cl *ChunkList) ByIndex(i uint64) Chunk {
	return cl.chunks[i]
}

// ByIndexWithProof returns an entity from the list by index and proof of membership
func (cl *ChunkList) ByIndexWithProof(i uint64) (Chunk, model.MembershipProof) {
	return cl.chunks[i], nil
}

// Size returns the number of chunks in the list
func (cl *ChunkList) Size() int {
	return len(cl.chunks)
}
