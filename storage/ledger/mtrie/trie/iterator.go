package trie

import "github.com/dapperlabs/flow-go/storage/ledger/mtrie/node"

// NodeIterator is an iterator over the nodes in a trie.
// It guarantees a DESCENDANTS-FIRST-RELATIONSHIP in the sequence of nodes it generates:
//   * Consider the sequence of nodes, in the order they are generated by NodeIterator.
//     Let `node[k]` denote the node with index `k` in this sequence.
//   * Descendents-First-Relationship means that for any `node[k]`, all its descendents
//     have indices strictly smaller than k in the iterator's sequence.
// The Descendents-First-Relationship has the following important property:
// When re-building the Trie from the sequence of nodes, one can build the trie on the fly,
// as for each node, the children have been previously encountered.
type NodeIterator struct {
	// internally, NodeIterator is basically just a stack. By construction, the head of
	// the stack always contains a node, whose descendents have already benn iterated.
	// The algorithm starts from the root and steps through the tree in depth-first search
	// order (prioritizing the left child over the rite, when descending).
	// It pushed the nodes it encounters on the stack, until it hits a leaf node
	// (which then forms the head of the stack). A the head is a leaf node, which has
	// no children, it can enumerated without restriction.
	// Whenever a new node `n` is recalled, the head of the stack is popped.
	// The popped node's parent `p` can either have one or two children.
	//   * If the parent `p` has only one child, this child is must be `n`.
	//     Therefore, by recalling `n`, we have recalled all ancestors of `p`
	//   * If the parent has two children:
	//       - if `n` is the left child, we haven't searched through `p.RightChild()`
	//         (as priority is given to the left child)
	//         => we search p.RightChild() and push nodes in DFS manner on the stack
	//            until we hit the first leaf node again
	//       - if `n` is the right child, we haven already searched through all of `p`
	//         descendents (ad the `p.LeftChild` must have been searched before)
	//         => Therefore, by recalling `n`, we have recalled all ancestors of `p`
	// It follows by induction that the head of the stack always satisfies the
	// Descendents-First-Relationship. As we generally search the Tree in Depth-First-Search
	// manner, each node of the tree is recalled (once). Hence, the algorithm iterates all
	// nodes of the MTrie while guaranteeing Descendents-First-Relationship.
	stack []*node.Node
}

func newNodeIterator(trieRoot *node.Node, trieHeight int) *NodeIterator {
	i := &NodeIterator{
		stack: make([]*node.Node, 0, trieHeight),
	}
	i.digg(trieRoot)
	return i
}

func (i *NodeIterator) Next() (*node.Node, bool) {
	if len(i.stack) == 0 {
		return nil, false
	}
	head := i.pop()
	parent := i.peek()
	if parent.LeftChild() == head {
		i.digg(parent.RigthChild())
	}
	return head, true
}

func (i *NodeIterator) pop() *node.Node {
	headIdx := len(i.stack) - 1
	head := i.stack[headIdx]
	i.stack = i.stack[:headIdx]
	return head
}

func (i *NodeIterator) peek() *node.Node {
	return i.stack[len(i.stack)-1]
}

func (i *NodeIterator) digg(n *node.Node) {
	for {
		i.stack = append(i.stack, n)
		if lChild := n.LeftChild(); lChild != nil {
			n = lChild
			continue
		}
		if rChild := n.RigthChild(); rChild != nil {
			n = rChild
			continue
		}
		return
	}
}
