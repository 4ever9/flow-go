syntax = "proto3";

import "google/protobuf/timestamp.proto";

package bamboo.proto;

message SignedCollectionHash {
  bytes collectionHash = 1;
  repeated bytes signatures = 2;
}

message Collection {
  repeated SignedTransaction transactions = 1;
  bytes foundationBlockHash = 2;
}

message Block {
  string chainID = 1;
  uint64 height = 2;
  bytes previousBlockHash = 3;
  google.protobuf.Timestamp timestamp = 4;
  repeated SignedCollectionHash signedCollectionHashes = 5;
  repeated BlockSeal blockSeals = 6;
  repeated bytes signatures = 7;
}

// When computation results for past blocks become available, a corresponding execution receipt
// (issued by execution nodes) and result approval (issued by access nodes) is issued.
//
// We want to persist the execution receipt (assuming the results are consistent) and
// the result approval in subsequent blocks. This step is called _sealing a block_.
//
// This is a sub-message for a block seal. This will allow us later to (optionally) seal
// multiple past blocks in one new block without revising the structure.
//
message BlockSeal {
  bytes blockHash = 1;
  bytes executionReceiptHash = 2;
  repeated bytes executionReceiptSignatures = 3; // Signatures from EN that issued the original ExecutionReceipt
  repeated bytes resultApprovalSignatures = 4; // Signatures from AN that approved the  ExecutionReceipt
}

message IntermediateRegisters {
  bytes transactionHash = 1;
  // the register changes at the end of computing the transaction
  repeated Register registers = 2;
  uint64 computeUsed = 3;
}

// Generated by each execution node individually; submitted to access nodes.
message ExecutionReceipt {
  bytes previousReceiptHash = 1;
  bytes blockHash = 2;
  repeated Register initialRegisters = 3; // Registers at start of the block
  repeated IntermediateRegisters intermediateRegistersList = 4;
  repeated bytes signatures = 5;
}

// Issued by the access nodes once they agree with the values
// for the computation that they were assigned to check.
message ResultApproval {
  uint64 blockHeight = 1;
  bytes executionReceiptHash = 2;
  bytes resultApprovalSignature = 3; // Signature over executionReceiptHash.  The equal payload across all ANs is needed for aggreagation into blockseals.
  uint64 proof = 4; // The verification proof.
  bytes signature = 5; // The final signature over all the above fields to prevent external manipulation.
}

message Transaction {
  bytes script = 1;
  uint64 nonce = 2;
  repeated TransactionRegister registers = 3;
  repeated bytes chunks = 4;
}

message SignedTransaction {
  Transaction transaction = 1;
  repeated bytes scriptSignatures = 2;
  bytes payerSignature = 3;
}

message Register {
  bytes id = 1;
  bytes value = 2;
}

message TransactionRegister {
  // Contains meta information of a register.
  // It doesn't contain the register value as it's only meant to pass information about a register, not it's contents.

  enum AccessMode {
    CREATE = 0;
    // Allows read-only access to the contents of the register as they were at the end of the previous block.
    SNAPSHOT_READ = 1;
    // Allows read-only access to the contents of the register as they were after all previous transactions
    // have been processed (including those in the same block).
    CONFIRMED_READ = 2;
    // Only valid for Balance Registers. Allows Snapshot Read access to the Register, plus the ability to
    // issue deferred additions on that register.
    DEFERRED_WRITE = 3;
    // Allows exclusive read/write access to the contents of the register; all writes from previous transactions
    // will be visible, and all writes made by this transaction will be visible to all subsequent transactions
    // (formally: Serializability).
    READ_WRITE = 4;
  }
  enum Type {
    SIMPLE = 0;
    CHUNK = 1;
    BALANCE = 2;
  }
  message KeyWeight {
    bytes key = 1;
    float weight = 2;
  }
  Type type = 1;
  AccessMode accessMode = 2;
  bytes id = 3;
  repeated KeyWeight keys = 4;
}

message Inventory {
  message Item {
    enum Type {
      TRANSACTION = 0;
      BLOCK = 1;
    }
    Type type = 1;
    bytes hash = 2;
  }
  repeated Item items = 1;
}

message InvalidExecutionReceiptChallenge {
  bytes executionReceiptHash = 1;
  bytes executionReceiptSignature = 2;
  int64 partIndex = 3;
  repeated IntermediateRegisters partTransactions = 4;
  bytes signature = 5;
}

message PingRequest {  
}

message PingResponse {
  bytes address = 1;
}

message UserTransactionRequest {
  SignedTransaction transaction = 1;
}

message UserTransactionResponse {
  SignedTransaction transaction = 1;
  bytes ownerAddress = 2;
  uint64 cluster = 3;
}

message ClusterTransactionRequest {
  SignedTransaction transaction = 1;
}

message ClusterTransactionResponse {
}

message TransactionRequest {
  bytes transactionHash = 1;
}

message TransactionResponse {
  enum State {
    OPEN = 0;
    FINALIZED = 1;
    GUARANTEED = 2;
    IN_BLOCK = 3;
  }

  SignedTransaction transaction = 1;
  State state = 2;
}

message CollectionRequest {
  bytes collectionHash = 1;
}

message CollectionResponse {
  enum State {
    OPEN = 0;
    FINALIZED = 1;
    GUARANTEED = 2;
    IN_BLOCK = 3;
  }
 
  Collection collection = 1;
  State state = 2;
}

message TransactionUpdateRequest {
  SignedTransaction transaction = 1;
  bytes accessSignature = 2;
}

message TransactionUpdateResponse {
  bytes accessSignature = 1;
}

message CollectionUpdateRequest {
  Collection collection = 1;
  bytes accessSignature = 2;
}

message CollectionUpdateResponse {
  bytes accessSignature = 1;
}

message AccessCollectionRequest {
  Collection collection = 1;
  repeated bytes accessSignatures = 2;
}

message AccessCollectionResponse {
}

message ProposeBlockRequest {
}

message ProposeBlockResponse {
}

message ProposeBlockUpdateRequest {
}

message ProposeBlockUpdateResponse {
}

message ExecuteBlockRequest {
  Block block = 1;
}

message ExecuteBlockResponse {
}

message NotifyBlockExecutedRequest {
  Block block = 1;
}

message NotifyBlockExecutedResponse {
}

message ProcessExecutionReceiptRequest {
  ExecutionReceipt executionReceipt = 1;
}

message ProcessExecutionReceiptResponse {
}

message ReceiptsByBlockHeightRequest {
  uint64 blockHeight = 1;
}

message ReceiptsByBlockHeightResponse {
  repeated ExecutionReceipt executionReceipts = 1;
}

message RegistersRequest {
  repeated bytes ids = 1;
}

message RegistersResponse {
  repeated Register registers = 1;
}

message BalanceRequest {
  bytes address = 1;
}

message BalanceResponse {
  bytes address = 1;
  bytes balance = 2;
}

message RegistersAtBlockHeightRequest {
  repeated bytes ids = 1;
  uint64 blockHeight = 2;
}

message GetBlockByHashRequest {
  bytes blockHash = 1;
}

message GetBlockByHeightRequest {
  uint64 blockHeight = 1;
}

message GetBlockResponse {
  Block block = 1;
}

message ProcessResultApprovalRequest {
  ResultApproval resultApproval = 1;
}

message ProcessResultApprovalResponse {
}

message StateTransition {
  bytes previousStateTransitionHash = 1;
  repeated bytes previousCommitApprovalSignatures = 2;
  uint64 height = 3;
  bytes value = 4;
}

message SignedStateTransition {
  StateTransition stateTransition = 1;
  bytes signature = 2;
}

message FinalizedStateTransition {
  SignedStateTransition signedStateTransition = 1;
  repeated bytes signatures = 2;
}

enum Vote {
  REJECT = 0;
  APPROVE = 1;
}

message StateTransitionVote {
  bytes stateTransitionHash = 1;
  Vote vote = 2;
  uint64 height = 3;
}

message SignedStateTransitionPrepareVote {
  StateTransitionVote stateTransitionVote = 1;
  bytes signature = 2;
}

message SignedStateTransitionCommitVote {
  StateTransitionVote stateTransitionVote = 1;
  bytes signature = 2;
}

message FinalizedStateTransitionsRequest {
    repeated uint64 stateTransitionHeights = 1;
}

message FinalizedStateTransitionsResponse {
  repeated FinalizedStateTransition finalizedStateTransitions = 1;
}

message InvalidExecutionReceiptChallengeRequest {
  InvalidExecutionReceiptChallenge challenge = 1;
}

message InvalidExecutionReceiptChallengeResponse {
}
